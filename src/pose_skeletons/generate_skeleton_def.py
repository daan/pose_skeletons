import argparse
import sys
import os
import re
from textwrap import dedent


def sanitize_name(name: str) -> str:
    """Converts a string to a valid Python identifier for an Enum member."""
    # Replace invalid characters with underscore
    sanitized = re.sub(r'[^0-9a-zA-Z_]', '_', name)
    # Ensure it doesn't start with a number
    if sanitized and sanitized[0].isdigit():
        sanitized = '_' + sanitized
    return sanitized


def generate_definition_file(bvh_path: str, class_name: str, end_sites: bool = False):
    """
    Parses a BVH file to generate a Python SkeletonDefinition file.
    """
    try:
        from bvhtoolbox import BvhTree
    except ImportError:
        print("Error: 'bvhtoolbox' is not installed.")
        sys.exit(1)

    try:
        with open(bvh_path) as f:
            mocap = BvhTree(f.read())
    except FileNotFoundError:
        print(f"Error: BVH file not found at '{bvh_path}'")
        sys.exit(1)
    except Exception as e:
        print(f"Error reading BVH file: {e}")
        sys.exit(1)

    # Extract joint names and parent hierarchy from the BVH tree
    joints = mocap.get_joints(end_sites=end_sites)
    joint_names = [j.name for j in joints]
    name_to_index = {name: i for i, name in enumerate(joint_names)}
    
    parents = [-1] * len(joint_names)
    for i, joint_node in enumerate(joints):
        if joint_node and joint_node.parent:
            # The parent of the root node may be the HIERARCHY node, which is not
            # a joint and has no name, causing an IndexError.
            # We must check that the parent is a valid joint before getting its name.
            if len(joint_node.parent.value) > 1 and joint_node.parent.value[0] in ('ROOT', 'JOINT'):
                parent_idx = name_to_index.get(joint_node.parent.name)
                if parent_idx is not None:
                    parents[i] = parent_idx

    # --- Code Generation ---

    # 1. Create the IntEnum for joints
    output_class_name = sanitize_name(class_name).capitalize()
    enum_name = f"{output_class_name}Joints"
    sanitized_joint_names = [sanitize_name(name) for name in joint_names]
    
    enum_lines = []
    unique_sanitized_names = set()
    for i, name in enumerate(sanitized_joint_names):
        if name in unique_sanitized_names:
            print(f"Warning: Duplicate sanitized joint name '{name}' found. The generated Enum may be invalid.")
        unique_sanitized_names.add(name)
        enum_lines.append(f"    {name} = {i}")
    enum_def = f"class {enum_name}(IntEnum):\n" + "\n".join(enum_lines)

    # 2. Create the mapping to StandardJoint as a template
    standard_joint_names = [
        'hips', 'spine_low', 'spine_mid', 'spine_high', 'neck', 'head',
        'l_clavicle', 'l_shoulder', 'l_elbow', 'l_wrist',
        'r_clavicle', 'r_shoulder', 'r_elbow', 'r_wrist',
        'l_hip', 'l_knee', 'l_ankle', 'l_foot',
        'r_hip', 'r_knee', 'r_ankle', 'r_foot'
    ]
    map_lines = [
        "            # --- Standard Joint Mapping ---",
        "            # Edit these to map your skeleton's joints to the standard set.",
        f"            # Your joint enum is available as `{enum_name}`.",
        f"            # Example: self.hips = {enum_name}.Hips.value"
    ]
    for name in standard_joint_names:
        if name in ('l_clavicle', 'r_clavicle', 'l_hip', 'r_hip'):
            map_lines.append("")
        map_lines.append(f"            self.{name} = 0")
    map_str = "\n".join(map_lines)

    # 3. Assemble the full file content
    file_content = f"""
    # This file was generated by dev/generate_skeleton_def.py
    #
    # Next Steps:
    # 1. Move this file to: src/pose_skeletons/definitions/
    # 2. Edit the standard joint mapping below to map your skeleton's joints.
    # 3. Register your new skeleton in src/pose_skeletons/__init__.py

    from enum import IntEnum
    from ..definition import SkeletonDefinition


    {enum_def}


    class {output_class_name}(SkeletonDefinition):
        def __init__(self):
            # The joint names from the BVH file.
            names = [j.name for j in {enum_name}]
            
            # The parent index for each joint. -1 for root.
            parents = {repr(parents)}

            super().__init__("{output_class_name}", names, parents)
            
{map_str}
    """
    file_content = dedent(file_content).strip()

    # 4. Write to file in the current working directory
    sanitized_filename = f"{output_class_name.lower()}.py"
    output_path = os.path.join(os.getcwd(), sanitized_filename)
    
    with open(output_path, "w") as f:
        f.write(file_content)
        
    print(f"\\nSuccessfully generated skeleton definition at: {output_path}")
    print("\\nNext steps:")
    print(f"1. Move '{sanitized_filename}' to 'src/pose_skeletons/definitions/'.")
    print("2. Edit the file to set the correct indices in the '_map'.")
    print("3. Register the new definition in 'src/pose_skeletons/__init__.py'.")


def generate_skeleton_def():
    parser = argparse.ArgumentParser(
        description="Generate a SkeletonDefinition class from a BVH file.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument("bvh_file", type=str, help="Path to the input BVH file.")
    parser.add_argument(
        "--name", 
        type=str, 
        required=True, 
        help="The base name for the generated class and file (e.g., 'MyCustomRig')."
    )
    parser.add_argument(
        "--end-sites",
        action="store_true",
        help="Include BVH End Sites in the generated skeleton definition."
    )
    args = parser.parse_args()
    
    generate_definition_file(args.bvh_file, args.name, args.end_sites)

if __name__ == "__main__":
    generate_skeleton_def()
